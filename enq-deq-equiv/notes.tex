\documentclass{amsart}

% font
\usepackage{cmbright}

% margin 
\usepackage[margin=1in]{geometry}

% references
\usepackage[colorlinks]{hyperref} 
\PassOptionsToPackage{colorlinks}{hyperref}
\hypersetup{urlcolor = RedViolet, linkcolor = RoyalBlue, citecolor = NavyBlue}

% basics
\usepackage[leqno]{amsmath}
\usepackage{amssymb, amsthm} 
\usepackage[svgnames, dvipsnames]{xcolor}
\usepackage{mhsetup, mathtools}
\usepackage[capitalise]{cleveref}

% commutative diagram
\usepackage{tikz-cd}

% hats
\usepackage{yhmath}

% subfigures
\usepackage{subcaption}

% PL macros
\usepackage{mathpartir}
\usepackage{stmaryrd}
\newcommand{\inference}[3]{\inferrule*[Right=#1]{#2}{#3}}
\newcommand{\axiom}[2]{\inferrule*[Right=#1]{\;}{#2}}

% (Formal Abstractions macros)++
\DeclareMathOperator{\halfto}{\rightharpoonup}
\DeclareMathOperator{\pkt}{\mathrm{pkt}}
\DeclareMathOperator{\push}{\mathrm{push}}
\DeclareMathOperator{\pop}{\mathrm{pop}}
\DeclareMathOperator{\proj}{\mathrm{proj}}
\DeclareMathOperator{\Pkt}{\mathbf{Pkt}}
\DeclareMathOperator{\Rk}{\mathbf{Rk}}
\DeclareMathOperator{\Data}{\mathbf{Data}}
\DeclareMathOperator{\Topo}{\mathbf{Topo}}
\DeclareMathOperator{\Path}{\mathbf{Path}}
\DeclareMathOperator{\PIEO}{\mathbf{PIEO}}
\DeclareMathOperator{\PIFO}{\mathbf{PIFO}}
\DeclareMathOperator{\PIEOTree}{\mathbf{PIEOTree}}
\DeclareMathOperator{\PIFOTree}{\mathbf{PIFOTree}}
\DeclareMathOperator{\Leaf}{\mathrm{Leaf}}
\DeclareMathOperator{\Internal}{\mathrm{Internal}}
\DeclareMathOperator{\Node}{\mathrm{Node}}
\DeclareMathOperator{\St}{\mathbf{St}}
\DeclareMathOperator{\zin}{z_{\mathrm{in}}}
\DeclareMathOperator{\zout}{z_{\mathrm{out}}}

% Rio
\DeclareMathOperator{\Rio}{\mathbf{Rio}}
\DeclareMathOperator{\Fifo}{\mathbf{fifo}} % set2stream
\DeclareMathOperator{\EDF}{\mathbf{edf}}
\DeclareMathOperator{\RR}{\mathbf{rr}}     % stream2stream
\DeclareMathOperator{\Strict}{\mathbf{strict}}
\DeclareMathOperator{\Class}{\mathbf{Class}}
\DeclareMathOperator{\flow}{\mathbf{flow}}
\DeclareMathOperator{\class}{\mathrm{class}}
\DeclareMathOperator{\FIFO}{\mathbf{FIFO}}
\DeclareMathOperator{\CTopo}{\textbf{CTopo}}
\DeclareMathOperator{\RioTree}{\mathbf{RioTree}}
\DeclareMathOperator{\OrdTree}{\mathbf{OrdTree}}
\DeclareMathOperator{\PIFOControl}{\mathbf{PIFOControl}}
\DeclareMathOperator{\RioControl}{\mathbf{RioControl}}
\DeclareMathOperator{\zprepush}{z_{\mathrm{pre-push}}}
\DeclareMathOperator{\zprepop}{z_{\mathrm{pre-pop}}}
\DeclareMathOperator{\zpostpop}{z_{\mathrm{post-pop}}}
\DeclareMathOperator{\tzprepush}{z^{\prime}_{\mathrm{pre-push}}}
\DeclareMathOperator{\tzprepop}{z^{\prime}_{\mathrm{pre-pop}}}
\DeclareMathOperator{\tzpostpop}{z^{\prime}_{\mathrm{post-pop}}}

% theorems
\newtheorem{thm}{Theorem}[section]
\newtheorem{lem}[thm]{Lemma}
\theoremstyle{definition}
\newtheorem{dfn}[thm]{Definition}
\newtheorem{abuse}[thm]{Abuse of Notation}
\newtheorem{ex}[thm]{Example}
\newtheorem{rem}[thm]{Remark}

% no more indent
\setlength{\parindent}{0pt}

% right-justified sections hack
\usepackage{titlesec}
\newcommand{\marginsecnumber}[1]{%
  \makebox[0pt][r]{#1\hspace{6pt}}%
}
\titleformat{\section}
  {\normalfont\Large\bfseries}
  {\marginsecnumber\thesection}
  {0pt}
  {}
\titleformat{\subsection}
  {\normalfont\large\bfseries}
  {\marginsecnumber\thesubsection}
  {0pt}
  {}
\titleformat{\subsubsection}
  {\normalfont\normalsize\bfseries}
  {\marginsecnumber\thesubsubsection}
  {0pt}
  {}

% tag on the right hack
\makeatletter
\newcommand{\leqnomode}{\tagsleft@true\let\veqno\@@leqno}
\newcommand{\reqnomode}{\tagsleft@false\let\veqno\@@eqno}
\makeatother

% align env labels are alphabets instead of numbers
\renewcommand\theequation{\alph{equation}}

% pseudocode
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\usepackage{listings}

\lstdefinestyle{custom}{
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{language=Python, style=custom}

\begin{document}

\pagestyle{empty}

{\LARGE \textbf{Dequeue-Side Semantics}}

\hrulefill\\

\reqnomode

\textbf{Disclaimer}: we assume familiarity with citeOG, adopt its notational conventions, and steal its definitions!

Further, we work with a specific subset of \emph{Rio}, denoted $\Rio$, namely
\begin{align*}
    \inference{set2stream}
    {c \in \Class}
    {\EDF[c], \Fifo[c] \in \Rio}
    &&
    \inference{stream2stream}
    {n \in \mathbb N\\ rs \in \Rio^n}
    {\Strict[rs], \RR[rs] \in \Rio}
\end{align*}

where $\Class$ is an opaque collection of \emph{classes}.

\section{Structure and Semantics of Rio Trees}

% \begin{dfn}
%     % Well-formed
%     We'll inductively define the map $\class : \Rio \to \mathcal P(\Class)$: 
%     \begin{align*}
%         \axiom{}
%         {\class(\Fifo[c]) = \{c\}}
%         &&
%         \inference{}
%         {\bigcup_{1 \leq i \leq |rs|} \class(rs[i]) = c}
%         {\class(\RR[rs]) = c}
%     \end{align*}
%     More succinctly, Rio programs are sent to the collection of classes living at their leaves.
% 
%     We say $r \in \Rio$ is \emph{well-formed}, denoted $\vdash r$, if no two leaves share the same class:
%     \begin{align*}
%         \axiom{}
%         {\vdash \Fifo[c]}
%         &&
%         \inference{}
%         {
%             \forall 1 \leq i \leq |rs|. \; \vdash rs[i] \\\\
%             \forall 1 \leq i < j \leq |rs|. \; \class(rs[i]) \cap \class(rs[j]) = \varnothing
%         }
%         {\vdash \RR[rs]}
%     \end{align*}
% \end{dfn}

% \begin{dfn}
%     Let $\CTopo$ be the set of tree topologies with leaves decorated by classes. 
%     More precisely,
%     \begin{align*}
%         \inference{}
%         {c \in \Class}
%         {(\ast, c) \in \CTopo}
%         &&
%         \inference{}
%         {n \in \mathbb N\\ ts \in \CTopo^n}
%         {\Node(ts) \in \CTopo}
%     \end{align*}
% \end{dfn}
% 
% \begin{abuse}
%     Removing the classes at the leaves yields an obvious map $\CTopo \to \Topo$
%     \begin{align*}
%         \axiom{}
%         {(\ast, c) \to \ast}
%         &&
%         \inference{}
%         {
%             ts \in \CTopo^n\\ 
%             ts^\prime \in \Topo^n\\ 
%             \forall 1 \leq i \leq n. \; ts[i] \to ts^\prime[i]
%         }
%         {\Node(ts) \to \Node(ts^\prime)}
%     \end{align*}
%     For $t \in \CTopo$ with $t \to t^\prime$, we'll occasionally use $t$ when we really mean the topology of the same shape, $t^\prime$.
% \end{abuse}

\begin{dfn}
    For topology $t \in \Topo$, the set $\RioTree(t)$ of \emph{Rio trees} over $t$ is defined by
    \begin{align*}
        \inference{}
        {p \in \PIFO(\Pkt)\\ c \in \Class}
        {\Leaf(p, c) \in \RioTree(\ast)}
        &&
        \inference{}
        {
            ts \in \Topo^n\\
            \forall 1 \leq i \leq n. \; qs[i] \in \RioTree(ts[i])
        }
        {\Internal(qs) \in \RioTree(\Node(ts))}
    \end{align*}
    These are trees with leaves decorated by both classes and PIFOs.
\end{dfn}

\begin{dfn}
    For topology $t \in \Topo$, the set $\OrdTree(t)$ of \emph{ordered trees} over $t$ is defined by
    \begin{align*}
        \axiom{}
        {\Leaf \in \OrdTree(\ast)}
        &&
        \inference{}
        {
            ts \in \Topo^n\\
            rs \in \Rk^{n}\\
            \forall 1 \leq i \leq n. \; os[i] \in \OrdTree(ts[i])
        }
        {\Internal(rs, os) \in \OrdTree(\Node(ts))}
    \end{align*}
    These are trees with each internal node's child given a rank, thereby inducing a total ordering of children.
\end{dfn}

Let $\flow : \Pkt \to \Class$ be an opaque mapping from packets to the class they belong to (flow inference).

\begin{dfn}
    For $t \in \Topo$, define $\push : \RioTree(t) \times \Pkt \times \Rk \halfto \RioTree(t)$ such that
    \begin{align*}
        \inference{}
        {
            \flow(\pkt) = c\\
            \push(p, \pkt, r) = p^\prime
        }
        {\push(\Leaf(p, c), \pkt, r) = \Leaf(p^\prime, c)}
        &&
        \inference{}
        {
            \forall 1 \leq i \leq |qs|. \; \push(qs[i], \pkt, r) = qs^\prime[i]
        }
        {\push(\Internal(qs), \pkt, r) = \Internal(qs^\prime)}
        &&
        \inference{}
        {
            \flow(\pkt) \neq c\\
        }
        {\push(\Leaf(p, c), \pkt, r) = \Leaf(p, c)}
    \end{align*}
    Informally, we recursively push to all subtrees but only the PIFOs on leaves with the packet's flow are updated.
\end{dfn}

\begin{dfn}
    For $t \in \Topo$, define $\pop : \RioTree(t) \times \OrdTree(t) \halfto \Pkt \times \RioTree(t)$ such that
    \begin{align*}
        \inference{}
        {\pop(p) = (\pkt, p^\prime)}
        {\pop(\Leaf(p, c), \Leaf) = (\pkt, \Leaf(p^\prime, c))}
        &&
        \inference{}
        {
            \exists 1 \leq i \leq |qs|. \; \pop(qs[i], os[i]) = (\pkt, q)\\
            \forall 1 \leq j \leq |qs|. \; j \neq i \land \pop(qs[j], os[j]) = (\pkt^\prime, q^\prime) \implies rs[i] < rs[j]
        }
        {\pop(\Internal(qs), \Internal(rs, os)) = (\pkt, \Internal(qs[q/i]))}
    \end{align*}
    Informally, we recursively pop the smallest ranked, poppable subtree.
\end{dfn}

\newpage 

\section{PIFO \& Rio Controls}

\begin{figure}[!htb]
    \begin{align*}
        &\inference{RioCtrl-Push}
        {
            \zprepush(s, \pkt) = (r, s^\prime)\\
            \push(q, \pkt, r) = q^\prime
        }
        {
            \push((s, q, \zprepush, \zprepop, \zpostpop), \pkt) 
            = 
            (s^\prime, q^\prime, \zprepush, \zprepop, \zpostpop)
        }\\
        &\inference{RioCtrl-Pop}
        {
            \zprepop(s) = (o, s^\prime)\\
            \pop(q, o) = (\pkt, q^\prime)\\
            \zpostpop(s^\prime, \pkt) = s^{\prime\prime}
        }
        {
            \pop((s, q, \zprepush, \zprepop, \zpostpop)) 
            = 
            (\pkt, (s^{\prime\prime}, q^\prime, \zprepush, \zprepop, \zpostpop))
        }\\
        &\inference{PIFOCtrl-Push}
        {
            \zprepush(s, \pkt) = (pt, s^\prime)\\
            \push(q, \pkt, pt) = q^\prime
        }
        {
            \push((s, q, \zprepush, \zpostpop), \pkt) 
            = 
            (s^\prime, q^\prime, \zprepush, \zpostpop)
        }\\
        &\inference{PIFOCtrl-Pop}
        {
            \pop(q) = (\pkt, q^\prime)\\
            \zpostpop(s, \pkt) = s^\prime
        }
        {
            \pop((s, q, \zprepush, \zpostpop)) 
            = 
            (\pkt, (s^\prime, q^\prime, \zprepush, \zpostpop))
        }
    \end{align*}
    \caption{Pushing and Popping Controls}
    \label{fig:control_push_pop}
\end{figure}

For these notes, we'll refer to \emph{controls} from citeOG as \emph{PIFO controls}.

\begin{dfn}
    Let $t \in \Topo$ and \emph{scheduling transactions} $\zprepush$ and $\zpostpop$ be partial functions
    \begin{align*}
        \zprepush &: \St \times \Pkt \halfto \Path(t) \times \St\\
        \zpostpop &: \St \times \Pkt \halfto \St
    \end{align*}
    Define $\PIFOControl(t, \zprepush, \zpostpop)$ to be the set of quadruples 
    $$(s, q, \zprepush, \zpostpop)$$
    where $s \in \St$ and $q \in \PIFOTree(t)$.
\end{dfn}

\begin{dfn}
    Let $t \in \Topo$ and \emph{scheduling transactions} $\zprepush, \zprepop, \zpostpop$ be partial functions
    \begin{align*}
        \zprepush &: \St \times \Pkt \halfto \Rk \times \St\\
        \zprepop  &: \St \halfto \OrdTree(t) \times \St\\
        \zpostpop &: \St \times \Pkt \halfto \St
    \end{align*}
    Define $\RioControl(t, \zprepush, \zprepop, \zpostpop)$ to be the set of quintuples 
    $$(s, q, \zprepush, \zprepop, \zpostpop)$$ 
    where $s \in \St$ and $q \in \RioTree(t)$.
\end{dfn}

Both controls admit $\push$ and $\pop$ operations:
\begin{align*}
    \push &: \PIFOControl(t, \zprepush, \zpostpop) \times \Pkt \to \PIFOControl(t, \zprepush, \zpostpop)\\
    \pop  &: \PIFOControl(t, \zprepush, \zpostpop) \to \Pkt \times \PIFOControl(t, \zprepush, \zpostpop)\\
    \push &: \RioControl(t, \zprepush, \zprepop, \zpostpop) \times \Pkt \to \RioControl(t, \zprepush, \zprepop, \zpostpop)\\
    \pop  &: \RioControl(t, \zprepush, \zprepop, \zpostpop) \to \Pkt \times \RioControl(t, \zprepush, \zprepop, \zpostpop)
\end{align*}

Their semantics are written out in full in \Cref{fig:control_push_pop}.

\begin{dfn}
    Define the $\to \; \subseteq \PIFOControl(t, \zprepush, \zpostpop) \times \PIFOControl(t, \zprepush, \zpostpop)$ by
    \begin{align*}
        \inference{}
        {\pkt \in \Pkt\\ \push c \pkt = c^\prime}
        {c \to c^{\prime}}
        &&
        \inference{}
        {\pop c = (\pkt, c^\prime)}
        {c \to c^{\prime}}
    \end{align*}
    i.e. $c \to c^\prime$ if $c^\prime$ is a push or pop from $c$.
    We write $\to^\ast$ for the reflexive transitive closure of $\to$.
\end{dfn}

\begin{dfn}
    A partial function
    $$
        f :  
        \RioControl(t, \zprepush, \zprepop, \zpostpop) 
        \halfto
        \PIFOControl(t^\prime, \tzprepush, \tzpostpop) 
    $$
    is \emph{simulation} if, for all $\pkt \in \Pkt$ and $f(c_1) = c_2$, the following conditions are satisfied:
    \begin{enumerate}
        \item There exists $f(c_{\text{init}}) = c^{\prime}_{\text{init}}$ where the trees in $c_{\text{init}}$ and $c^\prime_{\text{init}}$ hold empty PIFOs at the leaves.
        \item If $c_{\text{init}} \to^\ast c_1$,
            \begin{align}
                \pop(c_1) \text{ is undefined} &\implies \pop(c_2) \text{ is undefined}\\
                \pop(c_1) = (\pkt, c^\prime_1) &\implies \pop(c_2) = (\pkt, c^\prime_2) \land f(c_1^\prime) = c_2^\prime\\
                \push(c_1, \pkt) = c^\prime_1  &\implies \push(c_2, \pkt) = c^\prime_2 \land f(c_1^\prime) = c_2^\prime
            \end{align}
    \end{enumerate}
\end{dfn}

\newpage

\section{Enqueue and Dequeue-Side Equivalence}

All further discussion takes $\St = \text{set of dictionaries mapping $\textbf{string} \to \textbf{float}$}$ and $\Rk = \Class = \mathbb N$.

\subsection{Round-Robin}

\begin{figure}[!htb]
    \centering
    \begin{subfigure}[t]{0.49\linewidth}
        \lstinputlisting{sched_trans/rio/z_post-pop.pseudo}
        \lstinputlisting{sched_trans/rio/z_pre-pop.pseudo}
        \lstinputlisting{sched_trans/rio/z_pre_push.pseudo}
        \caption{Rio Control}
    \end{subfigure}
    \begin{subfigure}[t]{0.49\linewidth}
        \lstinputlisting{sched_trans/pifo/z_post-pop.pseudo}
        \lstinputlisting{sched_trans/pifo/z_pre-push.pseudo}
        \caption{PIFO Control}
    \end{subfigure}
    \caption{Scheduling Transactions}
\end{figure}

For $n \in \mathbb N$, let's put our theory to use by constructing PIFO and Rio controls for
\begin{align*}
    \RR[(\FIFO[0], \FIFO[1], \ldots, \FIFO[n - 1])] 
\end{align*}

Both controls use the same underlying topology, namely
$$
t = \Node((\underbrace{\ast, \ast, \ldots, \ast}_{n \text{ times}}))
$$
Figure \Cref{fig:placeholder} describes the scheduling transactions 



and showing they're in simulation.
This would show the equivalence of enqueue and dequeue-side semantics for a specific type of program!


\renewcommand\refname{\LARGE References}
\bibliographystyle{alpha}
\bibliography{refs}

\end{document}
